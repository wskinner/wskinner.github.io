<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Baby Weight</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121821;
      --ink: #e8eef7;
      --muted: #a8b3c7;
      --accent: #6aa9ff;
      --ok: #3ecf8e;
      --warn: #ffcc66;
      --err: #ff6b6b;
      --grid: #223246;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    }
    header { padding: 16px 20px; border-bottom: 1px solid #1b2533; }
    header h1 { margin: 0; font-size: 18px; font-weight: 600; letter-spacing: .2px; }
    header p { margin: 6px 0 0; color: var(--muted); font-size: 12px; }

    .wrap { display: grid; grid-template-columns: 340px 1fr; gap: 16px; padding: 16px; }

    .card {
      background: var(--panel); border: 1px solid #1b2533; border-radius: 14px; padding: 14px; box-shadow: 0 1px 0 rgba(255,255,255,0.03) inset;
    }
    .card h2 { margin: 4px 0 10px; font-size: 14px; font-weight: 600; color: var(--ink); }

    .controls { display: grid; gap: 10px; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; }
    label { font-size: 12px; color: var(--muted); }
    input[type="number"], input[type="text"], select {
      width: 120px; background: #0f1520; color: var(--ink); border: 1px solid #243449; border-radius: 10px; padding: 6px 8px; font-size: 12px;
    }
    input[type="checkbox"] { transform: translateY(1px); }
    .hint { font-size: 11px; color: var(--muted); margin-top: -4px; }

    .btns { display: flex; gap: 8px; flex-wrap: wrap; }
    button, .file {
      appearance: none; border: 1px solid #1f2a3a; background: #162031; color: var(--ink);
      padding: 8px 10px; border-radius: 10px; font-size: 12px; cursor: pointer; transition: .15s ease;
    }
    button:hover, .file:hover { border-color: #2a3b52; background: #1a2740; }
    button.primary { background: #173156; border-color: #274a76; }
    button.primary:hover { background: #1a3a69; }
    .file input { display:none; }

    #chart { width: 100%; height: 460px; background: #0d1420; border: 1px solid #1b2533; border-radius: 14px; }
    .legend { display:flex; gap:12px; align-items:center; font-size:12px; color: var(--muted); margin-top: 8px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display:inline-block; }
    .dot.obs { background: var(--warn); }
    .dot.fil { background: var(--accent); }
    .dot.smo { background: var(--ok); }

    .footer { padding: 8px 16px 16px; font-size: 11px; color: var(--muted); }
    .bad { color: var(--err); }
    .good { color: var(--ok); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .small { font-size: 11px; color: var(--muted); }

    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th, td { padding: 6px 8px; border-bottom: 1px solid #1b2533; text-align: left; }
    th { color: var(--muted); font-weight: 600; }
    .scroll { max-height: 180px; overflow: auto; border: 1px solid #1b2533; border-radius: 10px; }

		details.panel {
			border: 1px solid var(--grid, #dde3ea);
			border-radius: 8px;
			background: var(--bg, #fff);
			padding: 0;
			margin: 8px 0 16px;
		}

		details.panel > summary {
			cursor: pointer;
			user-select: none;
			padding: 10px 12px;
			font-weight: 600;
			list-style: none;
		}

		details.panel > summary::-webkit-details-marker { display: none; }

		/* simple chevron */
		details.panel > summary::after {
			content: '▸';
			float: right;
			transition: transform .15s ease;
		}
		details.panel[open] > summary::after { transform: rotate(90deg); }

		details.panel[open] { padding-bottom: 12px; }
		details.panel .grid { padding: 0 12px; }

		details.panel .grid {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
			gap: 8px 12px;
			align-items: center;
			padding: 0 12px 8px;
		}

		details.panel .grid label {
			display: flex;
			flex-direction: column;
			font-size: 12px;
			color: var(--muted);
		}

		details.panel .grid input[type="number"] {
			width: 100%;
			margin-top: 2px;
			background: #0f1520;
			color: var(--ink);
			border: 1px solid #243449;
			border-radius: 8px;
			padding: 4px 6px;
			font-size: 12px;
		}
  </style>
</head>
<body>
  <header>
    <h1>Baby Weight</h1>
    <p>Import CSV in Huckleberry export format. Estimate true weight using a Kalman filter.</p>
  </header>

  <div class="wrap">
    <section class="card">
      <h2>1) Data</h2>
      <div class="controls" style="margin-bottom:12px;">
        <label class="file"> <input id="file" type="file" accept=".csv" /> <span>Choose CSV…</span> </label>
        <div class="hint">CSV headers supported: <span class="mono">datetime, weight</span>. Datetime parsed by <span class="mono">Date</span>.</div>
        <div class="btns">
          <button id="run" class="primary" disabled>Process</button>
          <button id="download" disabled>Download Results CSV</button>
        </div>
      </div>

      <h2>2) Model</h2>
			<details id="kf-params" class="panel">
				<summary>Kalman filter parameters</summary>
				<div class="grid">
					<label>g₀ <input id="g0" type="number" step="1" value="30"></label>
					<label>σw₀ <input id="sw0" type="number" step="1" value="50"></label>
					<label>σg₀ <input id="sg0" type="number" step="1" value="50"></label>
					<label>σb₀ <input id="sb0" type="number" step="1" value="100"></label>
					<label>rStd <input id="rStd" type="number" step="1" value="5"></label>
					<label>qg <input id="qg" type="number" step="1" value="9"></label>
					<label>qw <input id="qw" type="number" step="1" value="0"></label>
					<label>τ (hours) <input id="tauH" type="number" step="0.1" value="2"></label>
					<label>σb <input id="sb" type="number" step="1" value="15"></label>
					<label>z-gate <input id="zgate" type="number" step="0.1" value="4"></label>
					<label><input id="useSmooth" type="checkbox" checked> RTS smoothing</label>
				</div>
			</details>
    </section>

    <section class="card" style="display:grid; grid-template-rows: auto 1fr auto; gap: 10px;">
      <div>
        <h2>Chart</h2>
        <div id="chart"></div>
        <div class="legend">
          <span class="dot obs"></span> Observed &nbsp;&nbsp;
          <span class="dot fil"></span> Filtered &nbsp;&nbsp;
          <span class="dot smo"></span> Smoothed
        </div>
      </div>
      <div>
        <h2>Run log</h2>
        <div class="scroll"><table id="log"><thead><tr>
          <th>#</th><th>Datetime</th><th>z (g)</th><th>ŵ (g)</th><th>ĝ (g/day)</th><th>b̂ (g)</th><th>Gate</th>
        </tr></thead><tbody></tbody></table></div>
      </div>
      <div class="footer small">All calculations are local in your browser.</div>
    </section>
  </div>

  <script>
    // ---------- Utilities ----------
    const fmtNum = (x, d=1) => (Number.isFinite(x)? x.toFixed(d): "");
    const by = (sel) => document.querySelector(sel);

		function parseCSV(text) {
			// --- tiny CSV splitter that respects quotes ---
			function splitCSV(line) {
				const out = [];
				let cur = '';
				let inQuotes = false;
				for (let i = 0; i < line.length; i++) {
					const c = line[i];
					if (c === '"') {
						if (inQuotes && line[i + 1] === '"') { // escaped quote
							cur += '"';
							i++;
						} else {
							inQuotes = !inQuotes;
						}
					} else if (c === ',' && !inQuotes) {
						out.push(cur);
						cur = '';
					} else {
						cur += c;
					}
				}
				out.push(cur);
				// trim cells
				return out.map(s => s.trim());
			}

			const lines = text.split(/\r?\n/).filter(s => s.trim().length);
			if (!lines.length) return [];

			// Parse header to detect format
			const header = splitCSV(lines[0]).map(h => h.replace(/^"|"$/g, ''));
			const hasGrowthFormat =
				header.some(h => /type/i.test(h)) &&
				header.some(h => /^start$/i.test(h)) &&
				header.some(h => /start\s*condition/i.test(h));

			const rows = [];

			if (hasGrowthFormat) {
				// Column indexes
				const idxType = header.findIndex(h => /type/i.test(h));
				const idxStart = header.findIndex(h => /^start$/i.test(h));
				const idxStartCond = header.findIndex(h => /start\s*condition/i.test(h));

				for (let i = 1; i < lines.length; i++) {
					const parts = splitCSV(lines[i]).map(v => v.replace(/^"|"$/g, ''));
					if (!parts.length) continue;

					const type = parts[idxType] || '';
					if (!/^\s*growth\s*$/i.test(type)) continue;

					const startStr = (parts[idxStart] || '').trim();
					const cond = (parts[idxStartCond] || '').trim();

					// Extract weight in kg from Start Condition (e.g., "3.59kg")
					const m = cond.match(/([\d.]+)\s*kg\b/i);
					if (!m) continue;
					const kg = parseFloat(m[1]);
					if (!Number.isFinite(kg)) continue;

					// Convert to grams (rounded to nearest gram)
					const w = Math.round(kg * 1000);

					// Parse timestamp
					const t = Date.parse(startStr.replace(' ', 'T'));
					if (!Number.isFinite(t)) continue;

					rows.push({ t, w, iso: new Date(t).toISOString() });
				}
			} else {
				// Fallback: original simple "datetime,weight_grams" format
				let hasHeader = false;
				let idxT = 0, idxW = 1;
				const first = splitCSV(lines[0]).map(s => s.replace(/^"|"$/g, ''));
				if (
					first.length >= 2 &&
					/date|time/i.test(first[0]) &&
					/weight|gram/i.test(first[1])
				) {
					hasHeader = true;
				}
				const start = hasHeader ? 1 : 0;

				for (let i = start; i < lines.length; i++) {
					const parts = splitCSV(lines[i]).map(s => s.replace(/^"|"$/g, ''));
					if (parts.length < 2) continue;
					const t = Date.parse((parts[idxT] || '').replace(' ', 'T'));
					const w = parseFloat(parts[idxW]);
					if (!Number.isFinite(t) || !Number.isFinite(w)) continue;
					rows.push({ t, w, iso: new Date(t).toISOString() });
				}
			}

			rows.sort((a, b) => a.t - b.t);
			return rows;
		}

    function download(filename, text) {
      const blob = new Blob([text], {type: 'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    // ---------- Linear algebra (3x3) ----------
    function matMul(A,B) { // 3x3 x 3x3
      const C = [[0,0,0],[0,0,0],[0,0,0]];
      for (let i=0;i<3;i++) for (let k=0;k<3;k++) {
        let s=0; for (let j=0;j<3;j++) s += A[i][j]*B[j][k]; C[i][k]=s;
      }
      return C;
    }
    function matVec(A,v){ return [A[0][0]*v[0]+A[0][1]*v[1]+A[0][2]*v[2], A[1][0]*v[0]+A[1][1]*v[1]+A[1][2]*v[2], A[2][0]*v[0]+A[2][1]*v[1]+A[2][2]*v[2]]; }
    function vecAdd(a,b){ return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
    function vecSub(a,b){ return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
    function matAdd(A,B){ return [[A[0][0]+B[0][0],A[0][1]+B[0][1],A[0][2]+B[0][2]],[A[1][0]+B[1][0],A[1][1]+B[1][1],A[1][2]+B[1][2]],[A[2][0]+B[2][0],A[2][1]+B[2][1],A[2][2]+B[2][2]]]; }
    function matSub(A,B){ return [[A[0][0]-B[0][0],A[0][1]-B[0][1],A[0][2]-B[0][2]],[A[1][0]-B[1][0],A[1][1]-B[1][1],A[1][2]-B[1][2]],[A[2][0]-B[2][0],A[2][1]-B[2][1],A[2][2]-B[2][2]]]; }
    function matT(A){ return [[A[0][0],A[1][0],A[2][0]],[A[0][1],A[1][1],A[2][1]],[A[0][2],A[1][2],A[2][2]]]; }
    function matInv3(A){ // regularized 3x3 inverse
      const a=A[0][0], b=A[0][1], c=A[0][2], d=A[1][0], e=A[1][1], f=A[1][2], g=A[2][0], h=A[2][1], i=A[2][2];
      // add tiny jitter to diagonal for stability
      const eps=1e-9; const Aeps=[[a+eps,b,c],[d,e+eps,f],[g,h,i+eps]];
      const ae=Aeps[0][0], be=Aeps[0][1], ce=Aeps[0][2], de=Aeps[1][0], ee=Aeps[1][1], fe=Aeps[1][2], ge=Aeps[2][0], he=Aeps[2][1], ie=Aeps[2][2];
      const A11 =  (ee*ie - fe*he);
      const A12 = -(de*ie - fe*ge);
      const A13 =  (de*he - ee*ge);
      const A21 = -(be*ie - ce*he);
      const A22 =  (ae*ie - ce*ge);
      const A23 = -(ae*he - be*ge);
      const A31 =  (be*fe - ce*ee);
      const A32 = -(ae*fe - ce*de);
      const A33 =  (ae*ee - be*de);
      const det = ae*A11 + be*A12 + ce*A13;
      if (Math.abs(det) < 1e-12) throw new Error('Matrix near singular');
      const invDet = 1/det;
      return [[A11*invDet, A21*invDet, A31*invDet], [A12*invDet, A22*invDet, A32*invDet], [A13*invDet, A23*invDet, A33*invDet]];
    }

    // ---------- Kalman + RTS for 3-state [w,g,b] ----------
    function runKalman(records, params) {
      const { g0, sw0, sg0, sb0, rStd, qg, qw, tauDays, sb, zGate, useSmooth } = params;
      if (records.length === 0) return { rows: [], filtered: [], smoothed: [] };

      const H = [1,0,1];
      const R = rStd*rStd;

      // init state
      let x = [ records[0].w, g0, 0 ];
      let P = [[sw0*sw0, 0, 0], [0, sg0*sg0, 0], [0,0, sb0*sb0]];

      const filtered = []; // {t, iso, z, w, g, b, gated?}
      const preds = [];    // store x^- and P^- for smoother
      const Fs = [];       // F_k for RTS
      const Ppreds = [];   // P^-
      const xs = [];       // x^ (filtered)
      const Ps = [];       // P^ (filtered)

      let tPrev = records[0].t;

      for (let k=0; k<records.length; k++) {
        const { t, w: z, iso } = records[k];
        const dtDays = k===0 ? 0 : Math.max(0, (t - tPrev) / 86400000);
        tPrev = t;

        // Build F and Q for this step
        const phi = Math.exp(- (dtDays / Math.max(1e-6, tauDays)) );
        const F = [ [1, dtDays, 0], [0,1,0], [0,0, phi] ];
        // Q components
        const Qg = [
          [ qg*(dtDays**3)/3, qg*(dtDays**2)/2, 0 ],
          [ qg*(dtDays**2)/2, qg*dtDays,        0 ],
          [ 0, 0, 0 ]
        ];
        const Qw = [ [ qw*dtDays, 0, 0 ], [0,0,0], [0,0,0] ];
        const Qb = [ [0,0,0],[0,0,0],[0,0,(1-phi*phi)*sb*sb] ];
        const Q = matAdd(matAdd(Qg,Qw),Qb);

        // Predict
        const xpred = matVec(F, x);
        const Ppred = matAdd( matMul( matMul(F,P), matT(F) ), Q );

        // Innovation
        const Hx = H[0]*xpred[0] + H[1]*xpred[1] + H[2]*xpred[2];
        const y = z - Hx;
        const S = H[0]*(Ppred[0][0]*H[0] + Ppred[0][1]*H[1] + Ppred[0][2]*H[2]) +
                  H[1]*(Ppred[1][0]*H[0] + Ppred[1][1]*H[1] + Ppred[1][2]*H[2]) +
                  H[2]*(Ppred[2][0]*H[0] + Ppred[2][1]*H[1] + Ppred[2][2]*H[2]) + R;

        const zScore = Math.abs(y)/Math.sqrt(S);
        let gated = false;
        if (zGate > 0 && zScore > zGate) {
          // Skip update, accept prediction
          x = xpred; P = Ppred; gated = true;
        } else {
          // Kalman gain K = P^- H^T S^{-1} ; since H is 1x3, K is 3x1
          const PHt = [
            Ppred[0][0]*H[0] + Ppred[0][1]*H[1] + Ppred[0][2]*H[2],
            Ppred[1][0]*H[0] + Ppred[1][1]*H[1] + Ppred[1][2]*H[2],
            Ppred[2][0]*H[0] + Ppred[2][1]*H[1] + Ppred[2][2]*H[2]
          ];
          const invS = 1 / S;
          const K = [ PHt[0]*invS, PHt[1]*invS, PHt[2]*invS ];
          // Update state
          x = [ xpred[0] + K[0]*y, xpred[1] + K[1]*y, xpred[2] + K[2]*y ];
          // Update covariance: P = (I-KH) Ppred
          const KH = [ [K[0]*H[0], K[0]*H[1], K[0]*H[2]],
                       [K[1]*H[0], K[1]*H[1], K[1]*H[2]],
                       [K[2]*H[0], K[2]*H[1], K[2]*H[2]] ];
          const I = [[1,0,0],[0,1,0],[0,0,1]];
          P = matMul( matSub(I, KH), Ppred );
        }

        // Store
        filtered.push({ t, iso, z, w: x[0], g: x[1], b: x[2], gated, zScore });
        preds.push({ xpred, Ppred });
        Fs.push(F);
        Ppreds.push(Ppred);
        xs.push([...x]);
        Ps.push([[...P[0]],[...P[1]],[...P[2]]]);
      }

      // RTS smoothing (optional)
      let smoothed = filtered.map((r,i)=>({ ...r }));
      if (useSmooth && filtered.length >= 2) {
        const n = filtered.length;
        let xhat = [...xs[n-1]];
        let Phat = [[...Ps[n-1][0]],[...Ps[n-1][1]],[...Ps[n-1][2]]];
        smoothed[n-1].ws = xhat[0]; smoothed[n-1].gs = xhat[1]; smoothed[n-1].bs = xhat[2];
        for (let k=n-2; k>=0; k--) {
          const Fk1 = Fs[k+1]; // F_{k+1}
          const Pk = Ps[k];
          const Pk1pred = Ppreds[k+1];
          let Ck;
          try {
            const Pk1inv = matInv3(Pk1pred);
            Ck = matMul( matMul(Pk, matT(Fk1)), Pk1inv );
          } catch (e) {
            // fallback: no smoothing for this step
            Ck = [[0,0,0],[0,0,0],[0,0,0]];
          }
          const xk = xs[k];
          const xk1 = xs[k+1];
          const dx = vecSub([xhat[0],xhat[1],xhat[2]], xk1);
          const Ck_dx = matVec(Ck, dx);
          xhat = vecAdd(xk, Ck_dx);
          // covariance smoothing omitted (not needed for plotting/export); can be added if required
          smoothed[k].ws = xhat[0]; smoothed[k].gs = xhat[1]; smoothed[k].bs = xhat[2];
        }
      } else {
        smoothed.forEach((r)=>{ r.ws = r.w; r.gs = r.g; r.bs = r.b; });
      }

      return { filtered, smoothed };
    }

		// ---------- Charting (Canvas) ----------
		function drawChart(container, data) {
			const el = container;
			el.innerHTML = '';
			const W = el.clientWidth || 800, H = el.clientHeight || 460;
			const canvas = document.createElement('canvas');
			canvas.width = W; canvas.height = H; canvas.style.width = '100%'; canvas.style.height = '100%';
			el.appendChild(canvas);
			const ctx = canvas.getContext('2d');

			if (!data || !data.length) {
				ctx.fillStyle = '#667'; ctx.font = '12px sans-serif';
				ctx.fillText('Load data and run the filter.', 16, 24); return;
			}

			const hasKey = k => data.some(d => Number.isFinite(d[k]));
			const wKey = hasKey('w') ? 'w' : (hasKey('z') ? 'z' : 'ws');

			const pad = { l: 48, r: 16, t: 54, b: 28 }; // room for top numbers
			const xs = data.map(d => d.t);
			const ys = [];
			data.forEach(d => { ys.push(d.z); ys.push(d.w); ys.push(d.ws); });

			let t0 = Math.min(...xs), t1 = Math.max(...xs);
			if (t1 === t0) t1 = t0 + 60 * 60 * 1000;

			const yNums = ys.filter(Number.isFinite);
			const y0 = Math.min(...yNums), y1 = Math.max(...yNums);
			const yrPad = (y1 - y0) * 0.08 || 10;
			const ymin = y0 - yrPad, ymax = y1 + yrPad;

			const sx = (W - pad.l - pad.r) / (t1 - t0);
			const sy = (H - pad.t - pad.b) / (ymax - ymin);
			const X = t => pad.l + (t - t0) * sx;
			const Y = v => H - pad.b - (v - ymin) * sy;

			// ---- top stats (use model state from rows) ----
			const last = data[data.length - 1];
			const currentWeight = Number.isFinite(last.ws) ? last.ws
														: Number.isFinite(last.w) ? last.w
                        : Number.isFinite(last[wKey]) ? last[wKey] : NaN;

  // g^ from model: prefer smoothed gs, then filtered g
  const gHat = Number.isFinite(last.gs) ? last.gs
               : Number.isFinite(last.g) ? last.g : NaN;

  ctx.save();
  ctx.textBaseline = 'top';
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink') || '#223';

  ctx.textAlign = 'left';
  ctx.font = '700 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillText(Number.isFinite(currentWeight) ? `${Math.round(currentWeight)} g` : '—', pad.l, 8);

  ctx.textAlign = 'right';
  ctx.font = '700 22px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillText(Number.isFinite(gHat) ? `${gHat >= 0 ? '+' : ''}${gHat.toFixed(1)} g/day` : '—', W - pad.r, 10);
  ctx.restore();

  // ---- grid ----
  ctx.fillStyle = '#9ab';
  ctx.font = '11px sans-serif';
  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
  ctx.lineWidth = 1;
  ctx.setLineDash([2, 3]);

  for (let k = 0; k <= 5; k++) {
    const v = ymin + (k / 5) * (ymax - ymin); const y = Y(v);
    ctx.beginPath(); ctx.moveTo(pad.l, y); ctx.lineTo(W - pad.r, y); ctx.stroke();
    ctx.fillText(v.toFixed(0) + ' g', 6, y + 4);
  }

  for (let k = 0; k <= 5; k++) {
    const t = t0 + (k / 5) * (t1 - t0); const x = X(t);
    ctx.beginPath(); ctx.moveTo(x, pad.t); ctx.lineTo(x, H - pad.b); ctx.stroke();
    ctx.fillText(new Date(t).toLocaleString(), x - 30, H - 8);
  }

  ctx.setLineDash([]);

  // draw helpers
  function polyline(getX, getY, color, width, alpha = 1) {
    ctx.strokeStyle = color; ctx.lineWidth = width; ctx.globalAlpha = alpha; ctx.beginPath();
    let started = false; for (const p of data) { const x = getX(p), y = getY(p); if (!started) { ctx.moveTo(x, y); started = true; } else { ctx.lineTo(x, y); } }
    ctx.stroke(); ctx.globalAlpha = 1;
  }

  // Observations
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--warn');
  for (const d of data) { const x = X(d.t), y = Y(d.z); ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill(); }

  // Filtered
  polyline(d => X(d.t), d => Y(d.w), getComputedStyle(document.documentElement).getPropertyValue('--accent'), 1.6);
  // Smoothed
  polyline(d => X(d.t), d => Y(d.ws), getComputedStyle(document.documentElement).getPropertyValue('--ok'), 1.8);
}
    // ---------- UI wiring ----------
    let records = [];
    by('#file').addEventListener('change', async (e) => {
      const f = e.target.files[0]; if (!f) return;
      const text = await f.text();
      records = parseCSV(text);
			console.log(records);
      const ok = records.length>0;
      by('#run').disabled = !ok; by('#download').disabled = true;
      drawChart(by('#chart'), []);
      const tbody = by('#log tbody'); tbody.innerHTML = '';
      if (!ok) alert('No valid rows found. Expect two columns: datetime, weight');
    });

    by('#run').addEventListener('click', () => {
      if (!records.length) return;
      const params = {
        g0: parseFloat(by('#g0').value),
        sw0: parseFloat(by('#sw0').value),
        sg0: parseFloat(by('#sg0').value),
        sb0: parseFloat(by('#sb0').value),
        rStd: Math.max(0.1, parseFloat(by('#rStd').value)),
        qg: Math.max(0, parseFloat(by('#qg').value)),
        qw: Math.max(0, parseFloat(by('#qw').value)),
        tauDays: Math.max(1e-6, parseFloat(by('#tauH').value)/24),
        sb: Math.max(0, parseFloat(by('#sb').value)),
        zGate: Math.max(0, parseFloat(by('#zgate').value)),
        useSmooth: by('#useSmooth').checked,
      };
      const { filtered, smoothed } = runKalman(records, params);
      // merge for display
      const rows = filtered.map((r,i)=>({ ...r, ws: smoothed[i].ws, gs: smoothed[i].gs, bs: smoothed[i].bs }));
      drawChart(by('#chart'), rows);

      // Fill log table
      const tbody = by('#log tbody'); tbody.innerHTML = '';
      rows.forEach((r, idx) => {
        const tr = document.createElement('tr');
        const flag = r.gated ? '<span class="bad">yes</span>' : '';
        tr.innerHTML = `<td>${idx+1}</td><td>${r.iso.replace('T',' ').replace('Z','')}</td><td>${fmtNum(r.z,0)}</td>`+
                       `<td>${fmtNum(r.w,0)}</td><td>${fmtNum(r.g,1)}</td><td>${fmtNum(r.b,0)}</td><td>${flag}</td>`;
        tbody.appendChild(tr);
      });

      // enable export
      by('#download').disabled = false;
      by('#download').onclick = () => {
        let csv = 'datetime,observed_g,filtered_w_g,filtered_g_g_per_day,filtered_b_g,smoothed_w_g,smoothed_g_g_per_day,smoothed_b_g,gated\n';
        rows.forEach(r => {
          csv += `${r.iso},${r.z},${r.w},${r.g},${r.b},${r.ws},${r.gs},${r.bs},${r.gated?1:0}\n`;
        });
        download('kalman_results.csv', csv);
      };
    });

    // Initial empty chart
    drawChart(by('#chart'), []);
  </script>
</body>
</html>
